# (cyc|ops)

## Pre Announcement
- [x] Shorthand
  - [x] Vector/seq as shorthand for fit?
	  - [x] Do this at `pattern` or at `ops`: Keep it at pattern till it causes a problem
	  - [x] Or do we need it at all?: Yes, improves the coding ergonomics, and has not yet caused issues
- [ ] Scale|ChordNthOp
- [?] Cyclops -> Cycl
- [/] Write tests
- [ ] *Minimal* Overtone interop
	- [ ] Make a decision on (metro)
	- [ ] Formalize dynamic dispatch
        - [ ] Default thing that's just going to call fns with context of values that are fns
        - [ ] Concepts of "outputs" (which will be orbits for Dirt and who knows for Overtone)
        - [ ] osc stuff should move to dirt namespace
	- Core functionality
	  - Events encapsulates timing and context
	  - Mergey stuff including param merging, maths, and applications
	  - Value is ANYTHING
	  - Timing and slices
	  - Orbit grouping
	  - Dispatch
		  - Attaches play start/len/stop
		  - Attaches context
		  - [?] Event or slice?
	  - Reduplication?
		  - Or is this post-dispatch
	- Dynamic dispatch methods
		- Custom
			- Get some events and do something with them
			- (Likely schedule and send them somewhere)
		- Dirt
			- Converts to dirt message and latency and sends
		- Overtone
			- Converts to overtone timed event
			- You do the rest!
		- OSC
			- Sends arbitrary osc messages
		- MIDI
			- Sends midi messages
		- Overdirt (roadmap)
			- Supports dirty features via overtone interface (events/synths/etc)
		- Superdough
			- Some sort of JS integration
	- [>] See about starting scsynth and getting the stuff
- [ ] Replicate Tidal/Strudel samples
  - [ ] Might as well document the source
  - [ ] Determine gaps
- [ ] Some actual music
- [ ] Core Tidal/Strudel stuff
  - [/] Effects
    - Early
    - Late
    - Rev
    - Iter (start at next not each cycle)
    - Compress
    - Swing
  - [/] Oscillators
  - [ ] Tidal/strudel reference
  - [ ] Sample selection (:bd:2)
  - [ ] Range scales input from, say, (range (sin) 0 500)???
## Architecture
- [x] Param ctrls `pan` et al
  - [x] Are these implemented via merge or do they take multiple patterns?
    - [a] Implemented via merge
      - Matches Tidal
      - Simpler
      - Merge has to happen either way
      - Complicates without much benefit
- [x] Should ctrls operate on cycls rather than performing the conversion
  - [/] Eh. Works well enough for now. Consider moving to `ops`
  - What would this look like if at pat level but shortcutted at ops level?
- [] Shorthand
  - [x] Vector/seq as shorthand for fit?
	  - [x] Do this at `pattern` or at `ops`
  - [-] Ditto but splice? ;=> Same fucking thing
  - [c] LazySeq/List as shorthand for cyc? ;=> Would confuse sequence stuff as inputs
  - [-] Base pat for input to Ops* ;=> Per vector/seq
## Core
- [/] Write tests
- [ ] Types?
- [ ] Replicate Tidal/Strudel samples
  - [ ] Might as well document the source
  - [ ] Determine gaps
- [ ] Some actual music
## Core Features
- [ ] scsynth startup
- [ ] Core Tidal/Strudel stuff
  - [/] Effects
  - [/] Oscillators
  - [ ] Tidal/strudel reference
  - [ ] Sample selection (:bd:2)
  - [ ] Range scales input from, say, (range (sin) 0 500)???
- [ ] Docs and examples
- [ ] Arps and arp patterns
  - [ ] higher-order `n`s
    - [ ] Scale-nth
    - [ ] chord
    - [ ] scale
## Marketing
- [ ] Videos
- [ ] Announce
- [ ] Present
- [ ] More collection mangling/specter examples
## Bonus Features
- [ ] Graphics
    - [ ] Processing
    - [ ] Quil
- [ ] Audio file playback
- [/] Sampling synth with pitch control like superdough
	- [ ] Port it to in Overtone
- [ ] Make OSC send pluggable
- [ ] Mini notation string
- [ ] LLM support (LLM help docs)
- [ ] Separate dirt add midi/osc
- [ ] Optimize recursion
## Ideas
- [ ] Overdirt (Supertone?) in Overtone
- [ ] AI composition
- [ ] Text playback
- [ ] Alternate method for realization?
  - [-] Promise?
  - [ ] @syntax?
  - [-] https://github.com/clj-commons/manifold
  - [ ] https://github.com/anjensan/knitty
  - [ ] https://github.com/hoplon/javelin
# Done
## Architecture
- [x] Get mixmatched pattern ops to work like Tidal?
  - [x] How does it work when there are more args than vals? (rep [2 3] :a)
  - [x] How does it work when there are more vals than args? (rep [2 3] :a :b :c)
- [x] Consider defmacro vs defprotocol
- [x] When do untimed patterns become timed cycles?
  - [!] `->cycl` called by `ctrls` and `ops/merge` fns and `ops` convenience funs
  - [x] And how do we make this intuitive.
  - [p] Has to happen on merge?
  - [c] And some pat ops - Rev implemented as Op. Ctrls should operate on ->cycls
    - [-] Rev? (probably not, but requires multi + two impl)
    - [x] Swing - Param ctrl
    - [x] Dragger or Rusher, particularly rush Param ctrl
- [c] Do I get rid of intermediate pattern representation
  - No: Has benefits for serialization and for timing implementation
- [x] When do unrealized patterns become cycles (i.e., seq of Events)?
  - fns should be explicit about whether they produce patterns (Op trees) or cycles (event seqs)
  - Any op that requires slicing (include merge) will need to return a cycle
    - Merge def returns cycle
    - Ctrl should also always return cycle
      - [?] Can a ctrl be the child of a Op? (fit (n 123) (s 234)) "[(n 5)]"
        - [c] Don't think so. So ctrl :: pat => cycl [:=> [:cat pat] cycle] :where (alias pat Operatic) (alias cycle (sequence Event))
  - And I think that's okay
- [c] Should Operatic be Pattern?
- [c] Do we need the Cyclic protocol or even the Cycle record? :: Got rid of it and it works great!
  - Pro
    - Set any period we want at the cycle leve
    - We can set any metadata we want at cycle level
    - Custom cycle-realization stuff
  - Cons
    - Extra data type
    - Wrapper fn around event updates
    - Built-in don't work for event seqs (without slicing first, anyway)
- [p] Do we need many Op records or just one? A: Many
  - Pro Many
    - Use Protocol, which defines things in one place
    - Don't need op symbols or to worry about collision
    - Don't need multiple definition statements (or macro) (i.e., define define fun and multi and etc.)
    - Each records only contains defined fields
    - Reader notation exists
    - Name args reasonably (vs `args`)
  - Cons
    - Need to define custom print method for each type (probably)
    - Simpler reader notation
    - Enforce `children` convention
    - Extra data types
  - [p] Operatic as protocol over multimethod
    - Pro (protocol)
      - One-step def without custom macro
      - Cleaner record member access
    - Cons
      - Requires type per op
- [c] Weighty as protocol over multimethod [6 to half a dozen]
  - Pro for protocol
    - Define everthing in one place (looks nicer)
    - If operatic is protocol, feels consistent
    - Cleaner record member access
    - Current implementation
  - Con
    - [-] Won't work with one Op record
    - Have to define on nil and object
- [x] Review arg op vs pat op dichotomy
- [x] Patterns within pattners
  - [x] Seq as "default" behavior (sqeeze)
  - [-] Simplify ops that do the following ;=> Did not reduce code. Obscured functionality.
    - [-] Only xform children
      - `(rep [x & kids] (fit (cycle-n x kids)))`?
    - [-] Only manipulate weight
    - [-] Only do both
    - [-] Trivially derive patop from std op
- [-] Separate ops for single vs pattern form?
- [-] Context xf op => Tried it. Didn't look right, didn't feel right. More, not less code.
## Core
- [x] Get coding agents involved
- [x] Remove order for notes when untangling loops
- [x] Break out Ops from Pattern
- [x] Separate function realization from merge
- [x] Figure out why timing doesn't work
- [x] Smart splat
- [x] Reduplicate
- [x] > < <> Merge
- [x] Shorter hand
  - [-] Magic n/s parsing? => No, because we need to know which is which
  - [x] Default merge (o 1 :bd :sd :sd) (o 1 [1 2 3 4] [:supersaw]) :or (o 1 [:bd :sd :sd])
- [x] Once
- [x] Stack merge
- [x] Core Tidal/Strudel stuff
  - [x] OSC
  - [x] Cycling timer
  - [x] Event representation
  - [x] Pattern representation
  - [x] Pattern notation
  - [x] Pattern mixing
  - [x] Euc
  - [-] Splice as default for []s? => Then they can't be used for fit.
- [x] Randomized events
- [x] Mix in Overtone music namespace
- [x] Break out namespaces
- [x] Implement */
- [x] Write tests
- [x] Live cps changes
- [x] Mini notation macro/data
- [x] Data notation
- [x] Fix `slow`
- [-] Get pattern back from Cycle? => Abandoned for now. Difficult to retain the metadata
- [x] Compare op merge with Tidal/Strudel
- [x] Fix op merge
- [x] Complete ctrl testing
- [x] Verify merge fns
- [-] Try breaking out different merge modes => Doesn't factor out well.
- [-] Try FRP => Not a good fit. Don't pursue
- [x] Figure out op merge pattern
- [-] Namespace our ctrl params
## Core Features
## Bonus Features

# Dustin IRE Epic Dude
- [?] What services do need to be always-on?
	- [x] Covered
- [?] What things would need to be tested incrementally
- [ ] How does user auth and directory syncing work?
- [ ] What are the high-level setup for the services
	- ODB
	- Monitoring
	- Hyper
	- Inter
	- Do these auto-scale?
- How automated can the dr be
-  
